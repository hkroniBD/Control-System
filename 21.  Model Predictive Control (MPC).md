
# üìò Lecture: Model Predictive Control (MPC) ‚Äì From Concept to Applications (with MATLAB Implementation)

---

## 1. üîé Introduction

Model Predictive Control (MPC) is a **modern advanced control strategy** widely used in process industries, robotics, automotive, and energy systems.

‚ú® **Key Features:**
- Uses a **mathematical model** of the plant to predict future behavior  
- Solves an **optimization problem** at each sampling instant  
- Explicitly handles **constraints** on inputs and states  
- Provides **optimal control actions** over a prediction horizon  

üìù **Note:** MPC is also known as **Receding Horizon Control (RHC)**.

---

## 2. ‚öôÔ∏è Core Working Principle

Imagine driving a car at night with headlights on.  
You **look ahead** a certain distance (prediction horizon) and **adjust steering & speed**.  
After moving a bit forward, you **recalculate** with updated information.

This is exactly how MPC works.

---

### üîÑ Workflow Diagram (Conceptual)

1. **Plant Model** ‚Üí Predicts future system states  
2. **Optimization** ‚Üí Minimizes cost function (performance index)  
3. **Constraints** ‚Üí Ensures safe & feasible operation  
4. **Controller Output** ‚Üí Apply only the **first control action**  
5. **Repeat** at next sampling instant

---

## 3. üìê Mathematical Formulation (Simplified)

MPC typically solves:

**Optimization Problem:**  

Minimize  
\[
J = \sum_{k=0}^{N_p} \| y(k) - r(k) \|^2_Q + \sum_{k=0}^{N_c} \| \Delta u(k) \|^2_R
\]

Subject to:  
\[
x(k+1) = Ax(k) + Bu(k)
\]  
\[
y(k) = Cx(k) + Du(k)
\]  
\[
u_{min} \leq u(k) \leq u_{max}, \quad x_{min} \leq x(k) \leq x_{max}
\]

Where:  
- \(N_p\) = Prediction Horizon  
- \(N_c\) = Control Horizon  
- \(Q, R\) = Weighting matrices  
- \(u, y, x\) = Control input, output, state  

---

## 4. üìä Components of MPC

| **Component** | **Description** | **Icon** |
|---------------|-----------------|----------|
| **Prediction Model** | State-space or transfer function model predicting future | üîÆ |
| **Cost Function** | Balances performance (tracking error) vs. effort (control usage) | ‚öñÔ∏è |
| **Constraints** | Limits on input, output, state (safety, physical bounds) | üöß |
| **Optimization Solver** | Computes optimal control input in real-time | üñ•Ô∏è |
| **Receding Horizon** | Only first input applied; problem re-solved each step | üîÑ |

---

## 5. üìå Advantages of MPC

‚úÖ Handles **multi-variable systems**  
‚úÖ Directly incorporates **constraints**  
‚úÖ Predictive & proactive (looks into the future)  
‚úÖ Flexible: can integrate with AI, ML, Digital Twins  

---

## 6. ‚ö†Ô∏è Limitations of MPC

‚ùå Requires **accurate system model**  
‚ùå **Computationally expensive** (real-time optimization)  
‚ùå May face difficulties with **nonlinearities** or **fast dynamics**  
‚ùå Tuning horizons & weights can be challenging  

---

## 7. üåç Applications of MPC

| **Domain**       | **Examples** | **Benefit** |
|------------------|-------------|-------------|
| üè≠ Process Industry | Chemical reactors, oil refining | Energy saving, quality control |
| üöó Automotive | Adaptive cruise control, fuel optimization | Safety, efficiency |
| ü§ñ Robotics | Path tracking, motion planning | Smooth, constraint-aware control |
| ‚ö° Energy Systems | Smart grids, wind turbines | Stability, optimal scheduling |
| üöâ Transportation | Train speed control, traffic flow | Efficiency, congestion reduction |

---

## 7+. üåç More Real-World Examples of MPC

- **Chemical Process Control** ‚Üí distillation, cement kilns  
- **Oil & Gas** ‚Üí refinery optimization, well pressure  
- **Power Systems** ‚Üí battery energy storage, smart grids  
- **Autonomous Vehicles** ‚Üí trajectory planning, collision avoidance  
- **Aerospace** ‚Üí spacecraft docking, satellite attitude control  
- **HVAC Systems** ‚Üí energy-efficient climate control  
- **Medical Applications** ‚Üí artificial pancreas (insulin dosing)  

---

## 8. üß† Types of MPC

1. **Linear MPC** ‚Äì assumes linear dynamics, fast and widely used  
2. **Nonlinear MPC (NMPC)** ‚Äì better accuracy for complex systems, but heavier computation  
3. **Robust MPC** ‚Äì deals with model uncertainties & disturbances  
4. **Economic MPC** ‚Äì directly optimizes operating cost instead of tracking error  

---

## 9. üìì Lecture Notes & Teaching Tips

- Use **real-life analogies** (driving, GPS navigation, budgeting).  
- Emphasize **constraints handling** as MPC‚Äôs superpower.  
- Show comparison with **PID controller**:  
  - PID = reactive, simple  
  - MPC = predictive, constraint-aware, optimization-based  

---

## 10. üîÑ MPC vs. Other Control Methods

| **Feature** | **PID** | **LQR** | **Fuzzy Control** | **Adaptive Control** | **MPC** |
|-------------|---------|---------|-------------------|----------------------|---------|
| **Approach** | Feedback, error-based | State-feedback, quadratic cost | Rule-based (linguistic) | Adjusts parameters in real-time | Prediction + Optimization |
| **Constraints** | ‚ùå Hard to handle | ‚ùå Not direct | ‚ùå Difficult | ‚ùå Limited | ‚úÖ Built-in |
| **Multi-variable systems** | ‚ùå Mostly SISO | ‚úÖ Handles MIMO | ‚úÖ Possible | ‚úÖ Possible | ‚úÖ Excellent |
| **Model requirement** | ‚ùå None (tuning only) | ‚úÖ Needs accurate model | ‚ùå Rule knowledge | ‚úÖ Needs adaptive model | ‚úÖ Needs accurate model |
| **Computation** | ‚ö° Very fast | ‚ö° Fast | ‚ö° Medium | ‚ö° Medium | üñ•Ô∏è Heavy (optimization) |
| **Robustness** | ‚úÖ Good if tuned | ‚úÖ Moderate | ‚úÖ Flexible | ‚úÖ Adaptive | ‚úÖ Robust (with Robust MPC) |
| **Examples** | Fan speed, heaters, pumps | Aircraft stability, robotics | Washing machines, consumer electronics | Communication systems | Smart grids, self-driving cars |

---

## 11. ‚öñÔ∏è Comparative Case Study ‚Äì Cruise Control

**Scenario:** A car is required to maintain a speed of 100 km/h. Constraints:  
- Maximum throttle = 100%  
- Maximum speed = 120 km/h  

| **Method** | **Performance** | **Limitations** |
|------------|-----------------|-----------------|
| **PID** | Maintains speed, simple design | Struggles with sudden slope or wind, no constraint handling |
| **LQR** | Optimal smooth control, better than PID | Needs full-state measurement, no direct constraints |
| **MPC** | Predicts slope ahead, adjusts throttle optimally, ensures speed ‚â§ 120 km/h | Requires car model + onboard computation |

üëâ **Conclusion:** PID works for flat terrain, LQR improves stability, but **MPC is the most realistic choice for modern cars** with constraints and future prediction.

---

## 12. üèÅ Summary

- MPC is a **predictive optimization-based control** strategy.  
- It solves a **constrained optimization problem** repeatedly in real time.  
- Provides significant advantages in **multi-variable, constrained, and high-performance systems**.  
- Compared with other controllers, MPC is **smarter, but heavier computationally**.  
- Widely used in **industry, robotics, energy, aerospace, automotive, and medicine**.  

---

## 13. üß© MATLAB Implementation of MPC

Below are **two ways** to implement MPC in MATLAB:
1) Using the **Model Predictive Control Toolbox** (recommended for rapid prototyping)  
2) A **from-scratch quadratic-program (QP)** formulation using `quadprog` (to understand the internals)

> üìù **Tip:** The MPC Toolbox automatically includes a state estimator (Kalman filter) when required. The QP example is intentionally compact to emphasize structure over edge cases.

---

### 13.1 üöó Linear MPC with Toolbox (Cruise Control Example)

**Plant (longitudinal vehicle model):**  
\(\dot{x} = \begin{bmatrix}0 & 1 \\ 0 & -b/m \end{bmatrix}x + \begin{bmatrix}0 \\ 1/m\end{bmatrix}u,\quad y = [1\;\;0]x\)  

```matlab
%% === Linear MPC with Toolbox (Cruise Control) ===
clear; clc; close all;

% Vehicle parameters
m = 1200;          % mass (kg)
b = 50;            % drag-ish lumped coefficient
A = [0 1; 0 -b/m];
B = [0; 1/m];
C = [1 0]; D = 0;

Ts = 0.1;          % sample time (s)
sysd = c2d(ss(A,B,C,D), Ts);

% MPC setup
Np = 20;           % prediction horizon
Nc = 3;            % control horizon
mpcobj = mpc(sysd, Ts, Np, Nc);

% Weights (tune as needed)
mpcobj.Weights.OutputVariables              = 1;
mpcobj.Weights.ManipulatedVariables         = 0.1;
mpcobj.Weights.ManipulatedVariablesRate     = 0.01;

% Constraints
mpcobj.MV.Min = 0;       % throttle min
mpcobj.MV.Max = 1;       % throttle max
mpcobj.OV.Min = -Inf;    % speed lower bound
mpcobj.OV.Max = 33.33;   % 120 km/h ‚âà 33.33 m/s

% Reference (100 km/h ‚âà 27.78 m/s)
Tsim = 200;
r = 27.78*ones(Tsim,1);

% Closed-loop simulation via mpcmove (explicit loop)
x = zeros(size(A,1),1);
xmpc = mpcstate(mpcobj);
U = zeros(Tsim,1); Y = zeros(Tsim,1); time = (0:Tsim-1)'*Ts;

for k = 1:Tsim
    y = C*x;                       % measure speed
    U(k) = mpcmove(mpcobj, xmpc, y, r(k));   % optimal throttle
    Y(k) = y;
    x = A*x + B*U(k);              % plant update
end

% Plots
figure('Name','MPC Cruise Control');
subplot(2,1,1);
plot(time, Y, 'LineWidth',1.2); hold on;
yline(27.78,'--','r=100 km/h');
yline(33.33,':','Speed limit');
ylabel('Speed y (m/s)'); grid on; title('Output');
legend('y','r','limit','Location','southeast');

subplot(2,1,2);
stairs(time, U, 'LineWidth',1.2);
ylabel('Throttle u'); xlabel('Time (s)'); grid on; title('Input');
```

**What to try next:**
- Increase \(N_p\) or \(N_c\) and see performance vs. computation.  
- Tighten \(u\) or \(y\) constraints to observe constraint handling.  
- Add a step disturbance to mimic hill/slope and observe MPC response.

---

### 13.2 üß± Build-Your-Own MPC (QP) with `quadprog`

This minimal example implements a **finite-horizon quadratic program** using output tracking and input **rate** \(\Delta u\) penalties, with **input and rate constraints**. It uses a standard **augmented-state** construction so that predictions are affine in the **sequence of input increments** \(\Delta U\).

```matlab
%% === Custom QP-based MPC (No Toolbox) ===
clear; clc; close all;

% Discrete-time plant (same vehicle model as before)
m = 1200;  b = 50;
A = [0 1; 0 -b/m]; B = [0; 1/m]; C = [1 0]; D = 0;
Ts = 0.1;
sysd = c2d(ss(A,B,C,D), Ts);
A = sysd.A; B = sysd.B; C = sysd.C;

nx = size(A,1); nu = size(B,2);

% Horizons
Np = 20;           % prediction horizon
Nc = 5;            % control horizon (Nc <= Np)

% Augmented system for Œîu formulation
% x_a = [x; u_prev]
Abar = [A B; zeros(1,nx) 1];
Bbar = [B; 1];
Cbar = [C 0];

% Prediction matrices: y_pred = F*x_a + Phi*ŒîU
F = zeros(Np, nx+1);
for i = 1:Np
    F(i,:) = Cbar*(Abar^i);
end

Phi = zeros(Np, Nc);
for i = 1:Np
    for j = 1:Nc
        if i-j >= 0
            Phi(i,j) = Cbar*(Abar^(i-j))*Bbar;
        end
    end
end

% Weights
Qy = eye(Np)*1.0;          % output tracking weight
Rdu = eye(Nc)*0.01;        % move suppression (Œîu) weight

% Quadratic cost: 0.5*ŒîU'HŒîU + f'ŒîU
H = (Phi'*Qy*Phi + Rdu);
H = (H + H')/2;            % ensure symmetry

% Constraints
u_min = 0;  u_max = 1;     % throttle limits
du_min = -0.1; du_max = 0.1;

% Cumulative-sum matrix so that U = u_prev*1 + S*ŒîU
S = tril(ones(Nc));

% Simulation
Tsim = 200; time = (0:Tsim-1)'*Ts;
r = 27.78*ones(Np,1);            % ref block for prediction horizon
x = zeros(nx,1); u_prev = 0;
U = zeros(Tsim,1); Y = zeros(Tsim,1);

opts = optimoptions('quadprog','Display','off');

for k = 1:Tsim

    % Current augmented state
    xa = [x; u_prev];

    % Gradient term
    f = Phi' * Qy * (F*xa - r);

    % Inequality constraints Aineq*ŒîU <= bineq
    % Input bounds via accumulated ŒîU:  u_min <= u_prev + S*ŒîU <= u_max
    Aineq_u = [ S; -S ];
    bineq_u = [ (u_max - u_prev)*ones(Nc,1);
                (u_prev - u_min)*ones(Nc,1) ];

    % Œîu bounds: du_min <= ŒîU <= du_max
    Aineq_du = [ eye(Nc); -eye(Nc) ];
    bineq_du = [ du_max*ones(Nc,1); -du_min*ones(Nc,1) ];

    Aineq = [Aineq_u; Aineq_du];
    bineq = [bineq_u; bineq_du];

    % Solve QP
    dU = quadprog(H, f, Aineq, bineq, [], [], [], [], [], opts);
    if isempty(dU), dU = zeros(Nc,1); end

    % Apply first move
    du = dU(1);
    u = u_prev + du;
    u = min(max(u, u_min), u_max);

    % Plant update
    y = C*x;
    Y(k) = y; U(k) = u;
    x = A*x + B*u;
    u_prev = u;
end

% Plot results
figure('Name','Custom QP-MPC');
subplot(2,1,1);
plot(time, Y, 'LineWidth',1.2); hold on;
yline(27.78,'--','r=100 km/h'); yline(33.33,':','Speed limit');
ylabel('Speed y (m/s)'); grid on; title('Output');
legend('y','r','limit','Location','southeast');

subplot(2,1,2);
stairs(time, U, 'LineWidth',1.2);
ylabel('Throttle u'); xlabel('Time (s)'); grid on; title('Input');
```

**Notes:**
- This QP uses **output tracking** and **Œîu** penalization. You can add **output constraints** similarly: enforce \(y_{min} \le y \le y_{max}\) using \(F x_a + \Phi \Delta U\).  
- If the system is **unstable** or noisy, add a **state estimator** (Kalman filter).  
- For **MIMO** plants, extend the lifted matrices to vector forms and use block-diagonal \(Q, R\).

---

## üéì Student Engagement Activity

- Design a simple MPC for cruise control:  
  - Prediction horizon = 5 sec  
  - Constraint: speed ‚â§ 120 km/h  
  - Goal: minimize fuel consumption  

- Compare performance (rise time, overshoot, input usage) for **PID vs LQR vs MPC** using the same plant.

---
