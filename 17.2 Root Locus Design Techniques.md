# ğŸ¯ Root Locus Design Techniques

## ğŸ“‹ Table of Contents
1. Introduction to Root Locus
2. Fundamental Concepts
3. Root Locus Construction Rules
4. Design Using Root Locus
5. Lead/Lag Compensation via Root Locus
6. Advanced Design Techniques
7. Practical Examples

---

## ğŸŒŸ Introduction to Root Locus

### What is Root Locus?

**Root Locus** is a graphical method that shows how the **closed-loop poles** of a system move in the complex plane as a **single parameter** (usually gain K) varies from 0 to âˆ.

Think of it like a **"roadmap of stability"** - it tells you where your system poles will travel as you turn up the gain knob!

### ğŸ­ The Big Picture

```
         +------+       +------+
r(s) --->| KÂ·Gc |------>| G(s) |-----> y(s)
         +------+       +------+
              |                |
              +--------(-)<----+
                    feedback
```

**Closed-Loop Transfer Function:**
```
T(s) = KÂ·Gc(s)Â·G(s) / [1 + KÂ·Gc(s)Â·G(s)Â·H(s)]
```

**Characteristic Equation:**
```
1 + KÂ·Gc(s)Â·G(s)Â·H(s) = 0
or
1 + KÂ·G_OL(s) = 0     where G_OL = open-loop transfer function
```

### ğŸ¯ Why Root Locus?

**Advantages:**
- ğŸ” **Visual Understanding** - See stability regions instantly
- âš¡ **Quick Design** - Find suitable gain K graphically
- ğŸ¨ **Intuitive** - Physical meaning of pole locations
- ğŸ”§ **Design Insight** - Shows where to add compensators
- ğŸ“Š **Performance Prediction** - Overshoot, settling time visible

**What It Tells Us:**
- âœ… Range of K for stability
- âœ… Dominant pole locations
- âœ… System damping and natural frequency
- âœ… Transient response characteristics
- âœ… Where compensation is needed

---

## ğŸ§® Fundamental Concepts

### ğŸ“ Pole Locations and System Behavior

The location of poles in the s-plane determines system behavior:

```
        jÏ‰ (imaginary axis)
         â†‘
    â‘¡   |   â‘         â‘  Unstable (right half-plane)
   -----+-----â†’ Ïƒ    â‘¡ Stable (left half-plane)
    â‘£   |   â‘¢        â‘¢ Overdamped (real axis, left)
         |            â‘£ Underdamped (complex, left)
                      â‘¤ Marginally stable (jÏ‰ axis)
```

### ğŸª Key Relationships

**For a pole at s = -Ïƒ Â± jÏ‰:**

**1. Natural Frequency:**
```
Ï‰n = âˆš(ÏƒÂ² + Ï‰Â²)
```

**2. Damping Ratio:**
```
Î¶ = Ïƒ/Ï‰n = cos(Î¸)
where Î¸ = angle from negative real axis
```

**3. Damped Frequency:**
```
Ï‰d = Ï‰ = Ï‰nâˆš(1 - Î¶Â²)
```

**4. Performance Metrics:**
```
Settling time:    ts â‰ˆ 4/Ïƒ     (2% criterion)
Peak time:        tp = Ï€/Ï‰d
Percent overshoot: %OS = 100Â·e^(-Ï€Î¶/âˆš(1-Î¶Â²))
```

### ğŸ¨ Constant Damping Lines

Lines of constant Î¶ are **radial lines** from origin:
```
Î¶ = 0.0  â†’ 90Â° (imaginary axis)
Î¶ = 0.3  â†’ 73Â°
Î¶ = 0.5  â†’ 60Â°
Î¶ = 0.707 â†’ 45Â°
Î¶ = 1.0  â†’ 0Â° (real axis)
```

### ğŸ§® Numerical Example 1: Pole Location Analysis

**Given:** A system has closed-loop poles at s = -2 Â± j3

**Calculate system characteristics:**

**Step 1: Natural Frequency**
```
Ï‰n = âˆš(ÏƒÂ² + Ï‰Â²) = âˆš(2Â² + 3Â²) = âˆš13 = 3.606 rad/s
```

**Step 2: Damping Ratio**
```
Î¶ = Ïƒ/Ï‰n = 2/3.606 = 0.555
```

**Step 3: Damped Frequency**
```
Ï‰d = Ï‰ = 3 rad/s
```

**Step 4: Performance Metrics**
```
Settling time:  ts = 4/Ïƒ = 4/2 = 2 seconds
Peak time:      tp = Ï€/Ï‰d = Ï€/3 = 1.047 seconds
Overshoot:      %OS = 100Â·e^(-Ï€Â·0.555/âˆš(1-0.555Â²)) = 12.8%
```

**Physical Interpretation:**
- âœ… System is **stable** (left half-plane)
- âœ… **Underdamped** (complex poles)
- âœ… Settles in **2 seconds**
- âœ… Small overshoot (**12.8%**) - good response!

---

## ğŸ“ Root Locus Construction Rules

### ğŸ¯ The 11 Rules of Root Locus

Given open-loop transfer function:
```
G_OL(s) = KÂ·N(s)/D(s) = KÂ·(s-zâ‚)(s-zâ‚‚)Â·Â·Â·/(s-pâ‚)(s-pâ‚‚)Â·Â·Â·
```

Where:
- **n** = number of poles
- **m** = number of zeros (m < n typically)

---

### **Rule 1: Number of Branches** ğŸ“Š
The root locus has **n branches**, one for each pole.

**Example:**
```
G(s) = K/(s(s+2)(s+5))
â†’ 3 poles â†’ 3 branches
```

---

### **Rule 2: Symmetry** ğŸ”„
Root locus is **symmetric about the real axis** (complex poles occur in conjugate pairs).

---

### **Rule 3: Real Axis Segments** â¡ï¸
Root locus exists on the real axis to the **left of an odd number** of real poles and zeros.

**Example:**
```
Poles at: 0, -2, -5
Zeros at: -3

Real axis segments:
âœ… Between 0 and -2  (1 pole to right)
âŒ Between -2 and -3 (2 poles to right)
âœ… Between -3 and -5 (3 poles + 1 zero = 2 to right)
âŒ Left of -5        (4 singularities to right)
```

---

### **Rule 4: Starting and Ending Points** ğŸ¬ğŸ­

- **Branches start (K=0)** at open-loop **poles**
- **Branches end (Kâ†’âˆ)** at open-loop **zeros** or infinity

---

### **Rule 5: Asymptotes** ğŸ“

For n > m, **(n-m) branches** go to infinity along asymptotes.

**Angles of asymptotes:**
```
Î¸â‚ = (2k+1)Â·180Â°/(n-m)    k = 0, 1, 2, ..., (n-m-1)
```

**Asymptote centroid (intersection point):**
```
Ïƒâ‚ = (Î£ real parts of poles - Î£ real parts of zeros)/(n-m)
```

---

### **Rule 6: Breakaway/Break-in Points** ğŸ’¥

Points where branches **leave or enter** the real axis.

**Found by solving:**
```
dK/ds = 0
or equivalently:
Î£[1/(s-páµ¢)] = Î£[1/(s-zâ±¼)]
```

---

### **Rule 7: Departure/Arrival Angles** ğŸ›«ğŸ›¬

**Departure angle from complex pole pâ‚–:**
```
Î¸d = 180Â° + Î£(angles from zeros) - Î£(angles from other poles)
```

**Arrival angle at complex zero zâ‚–:**
```
Î¸a = 180Â° - Î£(angles from zeros) + Î£(angles from poles)
```

---

### **Rule 8: Imaginary Axis Crossings** âš ï¸

Find where root locus crosses jÏ‰ axis (stability boundary).

**Method:** Routh-Hurwitz criterion or substitute s = jÏ‰ into characteristic equation.

---

### **Rule 9: Root Locus on Real Axis** ğŸ“
Between two adjacent poles on real axis, branches move toward each other and either:
- Break away into complex plane, or
- Meet and continue on real axis

---

### **Rule 10: Angle Condition** âˆ 
A point s is on the root locus if:
```
âˆ G_OL(s) = (2k+1)Â·180Â°    k = 0, Â±1, Â±2, ...
```

---

### **Rule 11: Magnitude Condition** ğŸ“
The gain K at any point s on root locus:
```
K = 1/|G_OL(s)|
```

---

## ğŸ§® Numerical Example 2: Complete Root Locus Construction

**Given System:**
```
G(s) = K/[s(s+2)(s+4)]
```

**Step 1: Identify poles and zeros**
```
Poles: pâ‚ = 0, pâ‚‚ = -2, pâ‚ƒ = -4
Zeros: none (m = 0)
n = 3, m = 0
```

**Step 2: Real axis segments (Rule 3)**
```
âœ… Between 0 and -2    (1 pole to right - ODD)
âŒ Between -2 and -4   (2 poles to right - EVEN)
âœ… Left of -4          (3 poles to right - ODD)
```

**Step 3: Asymptotes (Rule 5)**
```
Number of asymptotes: n - m = 3 - 0 = 3

Angles: Î¸â‚ = (2k+1)Â·180Â°/3
  k=0: Î¸â‚€ = 60Â°
  k=1: Î¸â‚ = 180Â°
  k=2: Î¸â‚‚ = 300Â° (or -60Â°)

Centroid: Ïƒâ‚ = (0 + (-2) + (-4) - 0)/(3-0) = -6/3 = -2
```

**Step 4: Breakaway points (Rule 6)**

From characteristic equation:
```
1 + K/[s(s+2)(s+4)] = 0
K = -s(s+2)(s+4) = -sÂ³ - 6sÂ² - 8s

dK/ds = -3sÂ² - 12s - 8 = 0
sÂ² + 4s + 8/3 = 0

s = [-4 Â± âˆš(16 - 32/3)]/2 = [-4 Â± âˆš(16/3)]/2
s = -0.845  or  s = -3.155
```

**Check validity:**
- s = -0.845 âœ… (between 0 and -2, on root locus)
- s = -3.155 âœ… (between -2 and -4... wait, not on RL!)

**Correct:** Only s = **-0.845** is valid breakaway point.

**Step 5: Imaginary axis crossing (Rule 8)**

Characteristic equation:
```
sÂ³ + 6sÂ² + 8s + K = 0
```

Routh array:
```
sÂ³ |  1      8
sÂ² |  6      K
sÂ¹ | (48-K)/6  0
sâ° |  K
```

For stability: K < 48

**At K = 48**, system crosses jÏ‰ axis:
```
6sÂ² + 48 = 0
sÂ² = -8
s = Â±j2.828
```

**Crossing frequency:** Ï‰ = **2.828 rad/s**

**Step 6: Summary**
```
âœ… 3 branches starting at poles (0, -2, -4)
âœ… All branches go to infinity
âœ… Asymptotes at 60Â°, 180Â°, -60Â° from point (-2, 0)
âœ… Breakaway at s = -0.845
âœ… Crosses jÏ‰ axis at Â±j2.828 when K = 48
âœ… Stable for 0 < K < 48
```

---

## ğŸ¨ Design Using Root Locus

### ğŸ¯ Design Procedure

**Step 1: Sketch Root Locus**
- Apply construction rules
- Identify key features

**Step 2: Specify Performance Requirements**
- Damping ratio Î¶
- Natural frequency Ï‰n
- Settling time ts
- Percent overshoot %OS

**Step 3: Determine Desired Pole Location**
```
From Î¶ and Ï‰n:
s_desired = -Î¶Ï‰n Â± jÏ‰nâˆš(1-Î¶Â²)
```

**Step 4: Check if Desired Pole is on Root Locus**
- Use angle condition
- If not on RL, need compensation

**Step 5: Find Gain K**
- Use magnitude condition at desired pole location

**Step 6: Verify Performance**
- Calculate actual Î¶, Ï‰n, ts, %OS
- Simulate if necessary

---

### ğŸ§® Numerical Example 3: Gain Selection Design

**Given:**
```
G(s) = K/[(s+1)(s+3)]
```

**Requirements:**
- Damping ratio: Î¶ â‰¥ 0.5
- Settling time: ts â‰¤ 4 seconds

**Step 1: Translate Requirements to s-plane**

For ts = 4 seconds:
```
ts = 4/Ïƒ
Ïƒ = 4/4 = 1
```

For Î¶ = 0.5:
```
Angle from negative real axis: Î¸ = cosâ»Â¹(0.5) = 60Â°
```

**Desired region:** Left of line Ïƒ = -1, within 60Â° cone.

**Step 2: Construct Root Locus**

Poles: -1, -3
```
Asymptotes: (2k+1)Â·180Â°/2
  Î¸ = 90Â°, 270Â° (vertical)
Centroid: Ïƒâ‚ = (-1-3)/2 = -2

Breakaway point:
K = -(s+1)(s+3) = -(sÂ² + 4s + 3)
dK/ds = -(2s + 4) = 0
s = -2 âœ… (on real axis between -1 and -3)
```

**Step 3: Find Point on Root Locus**

Try s = -1 + jâˆš3 (on 60Â° line from Ïƒ = -1):
```
Check angle condition:
âˆ G(s) = âˆ [1/((s+1)(s+3))]
      = -[âˆ (s+1) + âˆ (s+3)]
      = -[âˆ (jÎ”3) + âˆ (-2+jâˆš3)]
      = -[90Â° + 140.9Â°]
      = -230.9Â° â‰  180Â° âœ—
```

**Adjust:** Try s = -2 + j2:
```
âˆ (-1+j2) = 116.6Â°
âˆ (1+j2) = 63.4Â°
âˆ G(s) = -(116.6Â° + 63.4Â°) = -180Â° âœ…

On root locus!
```

**Step 4: Calculate Required Gain**
```
K = |(s+1)(s+3)| at s = -2+j2
  = |(-1+j2)(1+j2)|
  = |(-1+j2)| Â· |(1+j2)|
  = âˆš5 Â· âˆš5
  = 5
```

**Step 5: Verify Performance**
```
At s = -2 + j2:
Ïƒ = 2, Ï‰ = 2
Ï‰n = âˆš(4+4) = 2.828
Î¶ = 2/2.828 = 0.707 âœ… (> 0.5)
ts = 4/2 = 2 sec âœ… (< 4 sec)
%OS = 4.3% (excellent!)
```

**Final Design: K = 5**

---

## ğŸ¯ Lead Compensation Using Root Locus

### ğŸª Why Lead Compensation?

**Problem:** Desired pole location is **NOT on the original root locus**.

**Solution:** Add a **lead compensator** to reshape the root locus to pass through desired location.

### ğŸ“ Lead Compensator Structure

```
Gc(s) = Kc Â· (s + zc)/(s + pc)    where pc > zc
```

**Effect:** Adds phase lead (positive phase) to pull root locus to the left.

### ğŸ”§ Design Procedure

**Step 1:** Determine desired closed-loop pole location (s_d) from specs.

**Step 2:** Calculate **phase deficiency** Î¸_d at s_d:
```
Î¸_d = 180Â° - âˆ G(s_d)
```

**Step 3:** Choose lead compensator zero (zc) and pole (pc) to provide Î¸_d.

**Geometric method:**
- Place zc and pc symmetrically about s_d
- Angle contribution = Î¸_d

**Step 4:** Calculate compensator gain Kc to satisfy magnitude condition.

**Step 5:** Verify new root locus passes through s_d.

---

### ğŸ§® Numerical Example 4: Lead Compensator Design

**Given:**
```
G(s) = 4/[s(s+2)]
```

**Requirements:**
- Î¶ = 0.5
- Ï‰n = 4 rad/s

**Step 1: Desired Pole Location**
```
s_d = -Î¶Ï‰n Â± jÏ‰nâˆš(1-Î¶Â²)
    = -2 Â± j3.464
```

**Step 2: Check if on Original Root Locus**
```
âˆ G(s_d) at s = -2+j3.464:
âˆ s = 120Â° (from origin)
âˆ (s+2) = 90Â° (from -2)

âˆ G(s_d) = -(120Â° + 90Â°) = -210Â°

Phase condition: need -180Â°
Phase deficiency: Î¸_d = 180Â° - 210Â° = -30Â°

Actually: Î¸_d = 30Â° of phase LEAD needed âœ…
```

**Step 3: Design Lead Compensator**

Using trial-and-error or geometric method, choose:
```
zc = 3 (zero at -3)
pc = 6 (pole at -6)
```

**Verify angle contribution:**
```
At s_d = -2 + j3.464:
âˆ (s+3) = âˆ (1+j3.464) = 73.9Â°
âˆ (s+6) = âˆ (4+j3.464) = 40.9Â°

Angle from compensator: 73.9Â° - 40.9Â° = 33Â° âœ… (close to 30Â°)
```

**Step 4: Calculate Gain**

Total gain K needed at s_d:
```
KÂ·Gc(s) = KÂ·(s+3)/(s+6)
|KÂ·Gc(s_d)Â·G(s_d)| = 1

K = |s(s+2)(s+6)|/[4|s+3|]
  at s = -2+j3.464

K = |((-2+j3.464)(j3.464)(4+j3.464))|/[4|(1+j3.464)|]
  = 11.5
```

**Final Lead Compensator:**
```
Gc(s) = 11.5 Â· (s+3)/(s+6)
```

**Step 5: Verify Performance**

With compensator, closed-loop poles at s = -2 Â± j3.464:
```
âœ… Î¶ = 0.5 (as required)
âœ… Ï‰n = 4 rad/s (as required)
âœ… ts = 4/2 = 2 seconds
âœ… %OS = 16.3%
```

---

## ğŸŒ Lag Compensation Using Root Locus

### ğŸ¯ Why Lag Compensation?

**Problem:** Need to **increase low-frequency gain** without significantly affecting transient response.

**Solution:** Add a **lag compensator** with pole and zero **very close together** and near the origin.

### ğŸ“ Lag Compensator Structure

```
Gc(s) = Kc Â· (s + zc)/(s + pc)    where zc > pc
```

**Key Feature:** zc and pc very close to origin (typically < 0.1)

### ğŸ”§ Design Procedure

**Step 1:** Design for desired transient response (usually just proportional gain).

**Step 2:** Calculate steady-state error with K from Step 1.

**Step 3:** Determine required DC gain increase (Î²):
```
Î² = (desired Kv) / (actual Kv)
```

**Step 4:** Choose lag compensator:
```
zc = 0.1 (typical value)
pc = zc/Î²
Kc = 1
```

**Step 5:** Verify lag compensator doesn't significantly affect transient response.

---

### ğŸ§® Numerical Example 5: Lag Compensator Design

**Given:**
```
G(s) = K/[s(s+1)(s+4)]
```

**Requirements:**
- Î¶ = 0.5 for dominant poles
- Steady-state error for ramp â‰¤ 0.1

**Step 1: Design for Transient Response**

Desired poles: s = -1 Â± j1.732 (Î¶=0.5, Ï‰n=2)

From root locus, at these poles:
```
K = 7.5 (calculated using magnitude condition)
```

**Step 2: Calculate Steady-State Error**
```
Kv = lim[sâ†’0] sÂ·G(s) = K/4 = 7.5/4 = 1.875

For ramp input:
ess = 1/Kv = 1/1.875 = 0.533 âœ— (too large!)
```

**Step 3: Required Gain Increase**
```
Desired Kv = 1/0.1 = 10
Î² = 10/1.875 = 5.33
```

**Step 4: Design Lag Compensator**
```
Choose zc = 0.1
pc = zc/Î² = 0.1/5.33 = 0.0188

Gc(s) = (s + 0.1)/(s + 0.0188)
```

**Step 5: Verify**

New Kv:
```
Kv = 7.5 Ã— (0.1/0.0188) / 4 = 10 âœ…

New ess = 1/10 = 0.1 âœ… (meets requirement)
```

**Check transient response:**
- Dominant poles move only slightly to s â‰ˆ -1.05 Â± j1.75
- Î¶ â‰ˆ 0.51 (essentially unchanged) âœ…
- Settling time essentially same âœ…

**Final Design:**
```
Controller: Gc(s) = 7.5 Â· (s+0.1)/(s+0.0188)
Result: ess = 0.1, Î¶ â‰ˆ 0.5, ts â‰ˆ 4 sec
```

---

## ğŸª Advanced Root Locus Techniques

### ğŸ”„ 1. PID Controller Design via Root Locus

**PID Transfer Function:**
```
Gc(s) = Kp + Ki/s + KdÂ·s = (KdÂ·sÂ² + KpÂ·s + Ki)/s
```

This adds:
- One pole at origin (from integrator)
- Two zeros (from numerator)

**Design steps:**
1. Choose zero locations to shape desired response
2. Use root locus to find gains
3. Iterate to optimize performance

### ğŸ§® Numerical Example 6: PD Controller Design

**Given:**
```
G(s) = 1/(sÂ² + 2s + 2)
```

**Requirement:** Î¶ = 0.707

**Step 1: Original System Poles**
```
sÂ² + 2s + 2 = 0
s = -1 Â± j1
Î¶_original = 1/âˆš2 = 0.707 âœ… (already meets spec!)
```

But suppose we want **faster response** with same Î¶.

**Step 2: Design PD Controller**
```
Gc(s) = Kp + KdÂ·s = Kp(1 + TdÂ·s)
      = Kp(s + 1/Td)

Choose Td = 0.5, so zero at s = -2
```

**Step 3: New Root Locus**

System with PD:
```
G_new(s) = Kp(s+2)/(sÂ² + 2s + 2)
```

Find K for Î¶ = 0.707 on new root locus.

Desired poles: s = -2.83 Â± j2.83 (45Â° line, faster response)

```
Kp = 4 (from magnitude condition)
```

**Step 4: Results**
```
Original: Ï‰n = âˆš2 = 1.41, ts = 4/1 = 4 sec
With PD:  Ï‰n = 4, ts = 4/2.83 = 1.41 sec âœ…

Speed improvement: 2.8Ã— faster!
```

---

### ğŸ¯ 2. Dominant Pole Design

**Concept:** If poles are well-separated, the **closest poles to jÏ‰ axis** dominate response.

**Rule of Thumb:** Poles are dominant if they are **5Ã— closer** to jÏ‰ axis than other poles.

**Example:**
```
Poles at: -1Â±j2, -10, -12
Dominant: -1Â±j2 âœ…
Far poles: -10, -12 (can approximate as gain)
```

**Design Strategy:**
1. Design for dominant pole specifications
2. Ignore far poles initially
3. Verify assumption afterward

---

### ğŸ” 3. Root Locus for Other Parameters

Root locus can vary **any parameter**, not just gain!

**Examples:**
- Vary a time constant Ï„
- Vary damping ratio Î¶
- Vary zero/pole location

**Procedure:**
1. Rearrange characteristic equation to isolate parameter
2. Apply root locus rules
3. Interpret results

---

## ğŸ­ Real-World Applications

### ğŸš Application 1: Drone Attitude Control

**System:** Quadcopter pitch angle control
```
G(s) = 25/[sÂ²(s+5)]
```

**Requirements:**
- Settling time: ts â‰¤ 2 sec
- Overshoot: %OS â‰¤ 20%
- Zero steady-state error for step

**Solution Using Root Locus:**

**From specs:**
```
%OS = 20% â†’ Î¶ = 0.456
ts = 2 sec â†’ Ïƒ = 4/2 = 2
Ï‰n = Ïƒ/Î¶ = 2/0.456 = 4.39
Ï‰d = Ï‰nâˆš(1-Î¶Â²) = 3.91

Desired poles: s = -2 Â± j3.91
```

**Root locus shows:** Original locus doesn't pass through desired location.

**Add lead compensator:**
```
Gc(s) = K(s+3)/(s+12)
```

After design:
```
K = 86
Final poles: s = -2.1 Â± j3.88
Result: ts = 1.9 sec, %OS = 19.5% âœ…
```

---

### ğŸï¸ Application 2: Automotive Cruise Control

**System:** Vehicle speed control
```
G(s) = 10/[(s+1)(s+5)]
```

**Design for:**
- Fast response (ts < 3 sec)
- Minimal overshoot (%OS < 5%)
- Zero steady-state error

**Root Locus Analysis:**

Original system:
```
Dominant poles at s = -0.5 Â± j1.5 for K = 2
Î¶ = 0.316 â†’ %OS = 35% âœ— (too high!)
```

**Add PD controller:**
```
Gc(s) = Kp(1 + s) = Kp(s+1)
```

New root locus passes through better locations:
```
With Kp = 3, poles at s = -2.5 Â± j2
Î¶ = 0.78 â†’ %OS = 2% âœ…
ts = 4/2.5 = 1.6 sec âœ…
```

---

## ğŸ“ Design Guidelines and Tips

### âœ… Best Practices

**1. Always Start with Sketching**
- Hand sketch first (builds intuition)
- Use software to verify (MATLAB, Python)

**2. Check Your Work**
- Verify angle condition at selected points
- Calculate gain using magnitude condition
- Simulate final design

**3. Consider Implementation**
- Can you realize the compensator?
- Sensor noise effects?
- Actuator saturation?

**4. Use Dominant Pole Approximation**
- Simplifies design
- Focus on critical poles
- Verify assumption holds

**5. Multiple Iterations**
- First design rarely optimal
- Adjust and refine
- Balance competing requirements

### âš ï¸ Common Pitfalls

**âŒ Ignoring Far Poles/Zeros**
- May affect high-frequency behavior
- Can impact noise sensitivity

**âŒ Placing Compensator Poles/Zeros Poorly**
- Too close to desired poles â†’ affects location
- Too far â†’ minimal effect

**âŒ Forgetting Stability Margins**
- Root locus shows pole locations
- Still check gain/phase margins in frequency domain

**âŒ Over-Complicating Design**
- Start simple (P or PD)
- Add complexity only if needed

---

## ğŸ“Š Comparison: Root Locus vs. Frequency Methods

| Aspect | Root Locus | Frequency (Bode/Nyquist) |
|--------|-----------|--------------------------|
| **Domain** | s-plane | Frequency (jÏ‰) |
| **Intuition** | Time response | Stability margins |
| **Best for** | Transient specs | Robustness specs |
| **Parameter** | Single (usually K) | Frequency sweep |
| **Design** | Graphical, intuitive | Analytical, precise |
| **Advantage** | Visual pole placement | Noise, disturbance analysis |

**Best Practice:** Use **both methods** for complete design!

---

## ğŸ§® Summary Table: Design Methods

| Method | When to Use | Advantage | Limitation |
|--------|------------|-----------|------------|
| **Gain Adjustment** | RL passes through desired point | Simple, direct | Limited control |
| **Lead Comp** | Need faster response | Improves speed & stability |
