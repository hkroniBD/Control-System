# ğŸ¯ Root Locus Design Techniques

## ğŸ“‹ Table of Contents
1. Introduction to Root Locus
2. Fundamental Concepts
3. Root Locus Construction Rules
4. Design Using Root Locus
5. Lead/Lag Compensation via Root Locus
6. Advanced Design Techniques
7. Practical Examples

---

## ğŸŒŸ Introduction to Root Locus

### What is Root Locus?

**Root Locus** is a graphical method that shows how the **closed-loop poles** of a system move in the complex plane as a **single parameter** (usually gain K) varies from 0 to âˆ.

Think of it like a **"roadmap of stability"** - it tells you where your system poles will travel as you turn up the gain knob!

### ğŸ­ The Big Picture

```
         +------+       +------+
r(s) --->| KÂ·Gc |------>| G(s) |-----> y(s)
         +------+       +------+
              |                |
              +--------(-)<----+
                    feedback
```

**Closed-Loop Transfer Function:**
```
T(s) = KÂ·Gc(s)Â·G(s) / [1 + KÂ·Gc(s)Â·G(s)Â·H(s)]
```

**Characteristic Equation:**
```
1 + KÂ·Gc(s)Â·G(s)Â·H(s) = 0
or
1 + KÂ·G_OL(s) = 0     where G_OL = open-loop transfer function
```

### ğŸ¯ Why Root Locus?

**Advantages:**
- ğŸ” **Visual Understanding** - See stability regions instantly
- âš¡ **Quick Design** - Find suitable gain K graphically
- ğŸ¨ **Intuitive** - Physical meaning of pole locations
- ğŸ”§ **Design Insight** - Shows where to add compensators
- ğŸ“Š **Performance Prediction** - Overshoot, settling time visible

**What It Tells Us:**
- âœ… Range of K for stability
- âœ… Dominant pole locations
- âœ… System damping and natural frequency
- âœ… Transient response characteristics
- âœ… Where compensation is needed

---

## ğŸ§® Fundamental Concepts

### ğŸ“ Pole Locations and System Behavior

The location of poles in the s-plane determines system behavior:

```
        jÏ‰ (imaginary axis)
         â†‘
    â‘¡   |   â‘         â‘  Unstable (right half-plane)
   -----+-----â†’ Ïƒ    â‘¡ Stable (left half-plane)
    â‘£   |   â‘¢        â‘¢ Overdamped (real axis, left)
         |            â‘£ Underdamped (complex, left)
                      â‘¤ Marginally stable (jÏ‰ axis)
```

### ğŸª Key Relationships

**For a pole at s = -Ïƒ Â± jÏ‰:**

**1. Natural Frequency:**
```
Ï‰n = âˆš(ÏƒÂ² + Ï‰Â²)
```

**2. Damping Ratio:**
```
Î¶ = Ïƒ/Ï‰n = cos(Î¸)
where Î¸ = angle from negative real axis
```

**3. Damped Frequency:**
```
Ï‰d = Ï‰ = Ï‰nâˆš(1 - Î¶Â²)
```

**4. Performance Metrics:**
```
Settling time:    ts â‰ˆ 4/Ïƒ     (2% criterion)
Peak time:        tp = Ï€/Ï‰d
Percent overshoot: %OS = 100Â·e^(-Ï€Î¶/âˆš(1-Î¶Â²))
```

### ğŸ¨ Constant Damping Lines

Lines of constant Î¶ are **radial lines** from origin:
```
Î¶ = 0.0  â†’ 90Â° (imaginary axis)
Î¶ = 0.3  â†’ 73Â°
Î¶ = 0.5  â†’ 60Â°
Î¶ = 0.707 â†’ 45Â°
Î¶ = 1.0  â†’ 0Â° (real axis)
```

### ğŸ§® Numerical Example 1: Pole Location Analysis

**Given:** A system has closed-loop poles at s = -2 Â± j3

**Calculate system characteristics:**

**Step 1: Natural Frequency**
```
Ï‰n = âˆš(ÏƒÂ² + Ï‰Â²) = âˆš(2Â² + 3Â²) = âˆš13 = 3.606 rad/s
```

**Step 2: Damping Ratio**
```
Î¶ = Ïƒ/Ï‰n = 2/3.606 = 0.555
```

**Step 3: Damped Frequency**
```
Ï‰d = Ï‰ = 3 rad/s
```

**Step 4: Performance Metrics**
```
Settling time:  ts = 4/Ïƒ = 4/2 = 2 seconds
Peak time:      tp = Ï€/Ï‰d = Ï€/3 = 1.047 seconds
Overshoot:      %OS = 100Â·e^(-Ï€Â·0.555/âˆš(1-0.555Â²)) = 12.8%
```

**Physical Interpretation:**
- âœ… System is **stable** (left half-plane)
- âœ… **Underdamped** (complex poles)
- âœ… Settles in **2 seconds**
- âœ… Small overshoot (**12.8%**) - good response!

---

## ğŸ“ Root Locus Construction Rules

### ğŸ¯ The 11 Rules of Root Locus

Given open-loop transfer function:
```
G_OL(s) = KÂ·N(s)/D(s) = KÂ·(s-zâ‚)(s-zâ‚‚)Â·Â·Â·/(s-pâ‚)(s-pâ‚‚)Â·Â·Â·
```

Where:
- **n** = number of poles
- **m** = number of zeros (m < n typically)

---

### **Rule 1: Number of Branches** ğŸ“Š
The root locus has **n branches**, one for each pole.

**Example:**
```
G(s) = K/(s(s+2)(s+5))
â†’ 3 poles â†’ 3 branches
```

---

### **Rule 2: Symmetry** ğŸ”„
Root locus is **symmetric about the real axis** (complex poles occur in conjugate pairs).

---

### **Rule 3: Real Axis Segments** â¡ï¸
Root locus exists on the real axis to the **left of an odd number** of real poles and zeros.

**Example:**
```
Poles at: 0, -2, -5
Zeros at: -3

Real axis segments:
âœ… Between 0 and -2  (1 pole to right)
âŒ Between -2 and -3 (2 poles to right)
âœ… Between -3 and -5 (3 poles + 1 zero = 2 to right)
âŒ Left of -5        (4 singularities to right)
```

---

### **Rule 4: Starting and Ending Points** ğŸ¬ğŸ­

- **Branches start (K=0)** at open-loop **poles**
- **Branches end (Kâ†’âˆ)** at open-loop **zeros** or infinity

---

### **Rule 5: Asymptotes** ğŸ“

For n > m, **(n-m) branches** go to infinity along asymptotes.

**Angles of asymptotes:**
```
Î¸â‚ = (2k+1)Â·180Â°/(n-m)    k = 0, 1, 2, ..., (n-m-1)
```

**Asymptote centroid (intersection point):**
```
Ïƒâ‚ = (Î£ real parts of poles - Î£ real parts of zeros)/(n-m)
```

---

### **Rule 6: Breakaway/Break-in Points** ğŸ’¥

Points where branches **leave or enter** the real axis.

**Found by solving:**
```
dK/ds = 0
or equivalently:
Î£[1/(s-páµ¢)] = Î£[1/(s-zâ±¼)]
```

---

### **Rule 7: Departure/Arrival Angles** ğŸ›«ğŸ›¬

**Departure angle from complex pole pâ‚–:**
```
Î¸d = 180Â° + Î£(angles from zeros) - Î£(angles from other poles)
```

**Arrival angle at complex zero zâ‚–:**
```
Î¸a = 180Â° - Î£(angles from zeros) + Î£(angles from poles)
```

---

### **Rule 8: Imaginary Axis Crossings** âš ï¸

Find where root locus crosses jÏ‰ axis (stability boundary).

**Method:** Routh-Hurwitz criterion or substitute s = jÏ‰ into characteristic equation.

---

### **Rule 9: Root Locus on Real Axis** ğŸ“
Between two adjacent poles on real axis, branches move toward each other and either:
- Break away into complex plane, or
- Meet and continue on real axis

---

### **Rule 10: Angle Condition** âˆ 
A point s is on the root locus if:
```
âˆ G_OL(s) = (2k+1)Â·180Â°    k = 0, Â±1, Â±2, ...
```

---

### **Rule 11: Magnitude Condition** ğŸ“
The gain K at any point s on root locus:
```
K = 1/|G_OL(s)|
```

---

## ğŸ§® Numerical Example 2: Complete Root Locus Construction

**Given System:**
```
G(s) = K/[s(s+2)(s+4)]
```

**Step 1: Identify poles and zeros**
```
Poles: pâ‚ = 0, pâ‚‚ = -2, pâ‚ƒ = -4
Zeros: none (m = 0)
n = 3, m = 0
```

**Step 2: Real axis segments (Rule 3)**
```
âœ… Between 0 and -2    (1 pole to right - ODD)
âŒ Between -2 and -4   (2 poles to right - EVEN)
âœ… Left of -4          (3 poles to right - ODD)
```

**Step 3: Asymptotes (Rule 5)**
```
Number of asymptotes: n - m = 3 - 0 = 3

Angles: Î¸â‚ = (2k+1)Â·180Â°/3
  k=0: Î¸â‚€ = 60Â°
  k=1: Î¸â‚ = 180Â°
  k=2: Î¸â‚‚ = 300Â° (or -60Â°)

Centroid: Ïƒâ‚ = (0 + (-2) + (-4) - 0)/(3-0) = -6/3 = -2
```

**Step 4: Breakaway points (Rule 6)**

From characteristic equation:
```
1 + K/[s(s+2)(s+4)] = 0
K = -s(s+2)(s+4) = -sÂ³ - 6sÂ² - 8s

dK/ds = -3sÂ² - 12s - 8 = 0
sÂ² + 4s + 8/3 = 0

s = [-4 Â± âˆš(16 - 32/3)]/2 = [-4 Â± âˆš(16/3)]/2
s = -0.845  or  s = -3.155
```

**Check validity:**
- s = -0.845 âœ… (between 0 and -2, on root locus)
- s = -3.155 âœ… (between -2 and -4... wait, not on RL!)

**Correct:** Only s = **-0.845** is valid breakaway point.

**Step 5: Imaginary axis crossing (Rule 8)**

Characteristic equation:
```
sÂ³ + 6sÂ² + 8s + K = 0
```

Routh array:
```
sÂ³ |  1      8
sÂ² |  6      K
sÂ¹ | (48-K)/6  0
sâ° |  K
```

For stability: K < 48

**At K = 48**, system crosses jÏ‰ axis:
```
6sÂ² + 48 = 0
sÂ² = -8
s = Â±j2.828
```

**Crossing frequency:** Ï‰ = **2.828 rad/s**

**Step 6: Summary**
```
âœ… 3 branches starting at poles (0, -2, -4)
âœ… All branches go to infinity
âœ… Asymptotes at 60Â°, 180Â°, -60Â° from point (-2, 0)
âœ… Breakaway at s = -0.845
âœ… Crosses jÏ‰ axis at Â±j2.828 when K = 48
âœ… Stable for 0 < K < 48
```

---

## ğŸ¨ Design Using Root Locus

### ğŸ¯ Design Procedure

**Step 1: Sketch Root Locus**
- Apply construction rules
- Identify key features

**Step 2: Specify Performance Requirements**
- Damping ratio Î¶
- Natural frequency Ï‰n
- Settling time ts
- Percent overshoot %OS

**Step 3: Determine Desired Pole Location**
```
From Î¶ and Ï‰n:
s_desired = -Î¶Ï‰n Â± jÏ‰nâˆš(1-Î¶Â²)
```

**Step 4: Check if Desired Pole is on Root Locus**
- Use angle condition
- If not on RL, need compensation

**Step 5: Find Gain K**
- Use magnitude condition at desired pole location

**Step 6: Verify Performance**
- Calculate actual Î¶, Ï‰n, ts, %OS
- Simulate if necessary

---

### ğŸ§® Numerical Example 3: Gain Selection Design

**Given:**
```
G(s) = K/[(s+1)(s+3)]
```

**Requirements:**
- Damping ratio: Î¶ â‰¥ 0.5
- Settling time: ts â‰¤ 4 seconds

**Step 1: Translate Requirements to s-plane**

For ts = 4 seconds:
```
ts = 4/Ïƒ
Ïƒ = 4/4 = 1
```

For Î¶ = 0.5:
```
Angle from negative real axis: Î¸ = cosâ»Â¹(0.5) = 60Â°
```

**Desired region:** Left of line Ïƒ = -1, within 60Â° cone.

**Step 2: Construct Root Locus**

Poles: -1, -3
```
Asymptotes: (2k+1)Â·180Â°/2
  Î¸ = 90Â°, 270Â° (vertical)
Centroid: Ïƒâ‚ = (-1-3)/2 = -2

Breakaway point:
K = -(s+1)(s+3) = -(sÂ² + 4s + 3)
dK/ds = -(2s + 4) = 0
s = -2 âœ… (on real axis between -1 and -3)
```

**Step 3: Find Point on Root Locus**

Try s = -1 + jâˆš3 (on 60Â° line from Ïƒ = -1):
```
Check angle condition:
âˆ G(s) = âˆ [1/((s+1)(s+3))]
      = -[âˆ (s+1) + âˆ (s+3)]
      = -[âˆ (jÎ”3) + âˆ (-2+jâˆš3)]
      = -[90Â° + 140.9Â°]
      = -230.9Â° â‰  180Â° âœ—
```

**Adjust:** Try s = -2 + j2:
```
âˆ (-1+j2) = 116.6Â°
âˆ (1+j2) = 63.4Â°
âˆ G(s) = -(116.6Â° + 63.4Â°) = -180Â° âœ…

On root locus!
```

**Step 4: Calculate Required Gain**
```
K = |(s+1)(s+3)| at s = -2+j2
  = |(-1+j2)(1+j2)|
  = |(-1+j2)| Â· |(1+j2)|
  = âˆš5 Â· âˆš5
  = 5
```

**Step 5: Verify Performance**
```
At s = -2 + j2:
Ïƒ = 2, Ï‰ = 2
Ï‰n = âˆš(4+4) = 2.828
Î¶ = 2/2.828 = 0.707 âœ… (> 0.5)
ts = 4/2 = 2 sec âœ… (< 4 sec)
%OS = 4.3% (excellent!)
```

**Final Design: K = 5**

---

## ğŸ¯ Lead Compensation Using Root Locus

### ğŸª Why Lead Compensation?

**Problem:** Desired pole location is **NOT on the original root locus**.

**Solution:** Add a **lead compensator** to reshape the root locus to pass through desired location.

### ğŸ“ Lead Compensator Structure

```
Gc(s) = Kc Â· (s + zc)/(s + pc)    where pc > zc
```

**Effect:** Adds phase lead (positive phase) to pull root locus to the left.

### ğŸ”§ Design Procedure

**Step 1:** Determine desired closed-loop pole location (s_d) from specs.

**Step 2:** Calculate **phase deficiency** Î¸_d at s_d:
```
Î¸_d = 180Â° - âˆ G(s_d)
```

**Step 3:** Choose lead compensator zero (zc) and pole (pc) to provide Î¸_d.

**Geometric method:**
- Place zc and pc symmetrically about s_d
- Angle contribution = Î¸_d

**Step 4:** Calculate compensator gain Kc to satisfy magnitude condition.

**Step 5:** Verify new root locus passes through s_d.

---

### ğŸ§® Numerical Example 4: Lead Compensator Design

**Given:**
```
G(s) = 4/[s(s+2)]
```

**Requirements:**
- Î¶ = 0.5
- Ï‰n = 4 rad/s

**Step 1: Desired Pole Location**
```
s_d = -Î¶Ï‰n Â± jÏ‰nâˆš(1-Î¶Â²)
    = -2 Â± j3.464
```

**Step 2: Check if on Original Root Locus**
```
âˆ G(s_d) at s = -2+j3.464:
âˆ s = 120Â° (from origin)
âˆ (s+2) = 90Â° (from -2)

âˆ G(s_d) = -(120Â° + 90Â°) = -210Â°

Phase condition: need -180Â°
Phase deficiency: Î¸_d = 180Â° - 210Â° = -30Â°

Actually: Î¸_d = 30Â° of phase LEAD needed âœ…
```

**Step 3: Design Lead Compensator**

Using trial-and-error or geometric method, choose:
```
zc = 3 (zero at -3)
pc = 6 (pole at -6)
```

**Verify angle contribution:**
```
At s_d = -2 + j3.464:
âˆ (s+3) = âˆ (1+j3.464) = 73.9Â°
âˆ (s+6) = âˆ (4+j3.464) = 40.9Â°

Angle from compensator: 73.9Â° - 40.9Â° = 33Â° âœ… (close to 30Â°)
```

**Step 4: Calculate Gain**

Total gain K needed at s_d:
```
KÂ·Gc(s) = KÂ·(s+3)/(s+6)
|KÂ·Gc(s_d)Â·G(s_d)| = 1

K = |s(s+2)(s+6)|/[4|s+3|]
  at s = -2+j3.464

K = |((-2+j3.464)(j3.464)(4+j3.464))|/[4|(1+j3.464)|]
  = 11.5
```

**Final Lead Compensator:**
```
Gc(s) = 11.5 Â· (s+3)/(s+6)
```

**Step 5: Verify Performance**

With compensator, closed-loop poles at s = -2 Â± j3.464:
```
âœ… Î¶ = 0.5 (as required)
âœ… Ï‰n = 4 rad/s (as required)
âœ… ts = 4/2 = 2 seconds
âœ… %OS = 16.3%
```

---

## ğŸŒ Lag Compensation Using Root Locus

### ğŸ¯ Why Lag Compensation?

**Problem:** Need to **increase low-frequency gain** without significantly affecting transient response.

**Solution:** Add a **lag compensator** with pole and zero **very close together** and near the origin.

### ğŸ“ Lag Compensator Structure

```
Gc(s) = Kc Â· (s + zc)/(s + pc)    where zc > pc
```

**Key Feature:** zc and pc very close to origin (typically < 0.1)

### ğŸ”§ Design Procedure

**Step 1:** Design for desired transient response (usually just proportional gain).

**Step 2:** Calculate steady-state error with K from Step 1.

**Step 3:** Determine required DC gain increase (Î²):
```
Î² = (desired Kv) / (actual Kv)
```

**Step 4:** Choose lag compensator:
```
zc = 0.1 (typical value)
pc = zc/Î²
Kc = 1
```

**Step 5:** Verify lag compensator doesn't significantly affect transient response.

---

### ğŸ§® Numerical Example 5: Lag Compensator Design

**Given:**
```
G(s) = K/[s(s+1)(s+4)]
```

**Requirements:**
- Î¶ = 0.5 for dominant poles
- Steady-state error for ramp â‰¤ 0.1

**Step 1: Design for Transient Response**

Desired poles: s = -1 Â± j1.732 (Î¶=0.5, Ï‰n=2)

From root locus, at these poles:
```
K = 7.5 (calculated using magnitude condition)
```

**Step 2: Calculate Steady-State Error**
```
Kv = lim[sâ†’0] sÂ·G(s) = K/4 = 7.5/4 = 1.875

For ramp input:
ess = 1/Kv = 1/1.875 = 0.533 âœ— (too large!)
```

**Step 3: Required Gain Increase**
```
Desired Kv = 1/0.1 = 10
Î² = 10/1.875 = 5.33
```

**Step 4: Design Lag Compensator**
```
Choose zc = 0.1
pc = zc/Î² = 0.1/5.33 = 0.0188

Gc(s) = (s + 0.1)/(s + 0.0188)
```

**Step 5: Verify**

New Kv:
```
Kv = 7.5 Ã— (0.1/0.0188) / 4 = 10 âœ…

New ess = 1/10 = 0.1 âœ… (meets requirement)
```

**Check transient response:**
- Dominant poles move only slightly to s â‰ˆ -1.05 Â± j1.75
- Î¶ â‰ˆ 0.51 (essentially unchanged) âœ…
- Settling time essentially same âœ…

**Final Design:**
```
Controller: Gc(s) = 7.5 Â· (s+0.1)/(s+0.0188)
Result: ess = 0.1, Î¶ â‰ˆ 0.5, ts â‰ˆ 4 sec
```

---

## ğŸª Advanced Root Locus Techniques

### ğŸ”„ 1. PID Controller Design via Root Locus

**PID Transfer Function:**
```
Gc(s) = Kp + Ki/s + KdÂ·s = (KdÂ·sÂ² + KpÂ·s + Ki)/s
```

This adds:
- One pole at origin (from integrator)
- Two zeros (from numerator)

**Design steps:**
1. Choose zero locations to shape desired response
2. Use root locus to find gains
3. Iterate to optimize performance

### ğŸ§® Numerical Example 6: PD Controller Design

**Given:**
```
G(s) = 1/(sÂ² + 2s + 2)
```

**Requirement:** Î¶ = 0.707

**Step 1: Original System Poles**
```
sÂ² + 2s + 2 = 0
s = -1 Â± j1
Î¶_original = 1/âˆš2 = 0.707 âœ… (already meets spec!)
```

But suppose we want **faster response** with same Î¶.

**Step 2: Design PD Controller**
```
Gc(s) = Kp + KdÂ·s = Kp(1 + TdÂ·s)
      = Kp(s + 1/Td)

Choose Td = 0.5, so zero at s = -2
```

**Step 3: New Root Locus**

System with PD:
```
G_new(s) = Kp(s+2)/(sÂ² + 2s + 2)
```

Find K for Î¶ = 0.707 on new root locus.

Desired poles: s = -2.83 Â± j2.83 (45Â° line, faster response)

```
Kp = 4 (from magnitude condition)
```

**Step 4: Results**
```
Original: Ï‰n = âˆš2 = 1.41, ts = 4/1 = 4 sec
With PD:  Ï‰n = 4, ts = 4/2.83 = 1.41 sec âœ…

Speed improvement: 2.8Ã— faster!
```

---

### ğŸ¯ 2. Dominant Pole Design

**Concept:** If poles are well-separated, the **closest poles to jÏ‰ axis** dominate response.

**Rule of Thumb:** Poles are dominant if they are **5Ã— closer** to jÏ‰ axis than other poles.

**Example:**
```
Poles at: -1Â±j2, -10, -12
Dominant: -1Â±j2 âœ…
Far poles: -10, -12 (can approximate as gain)
```

**Design Strategy:**
1. Design for dominant pole specifications
2. Ignore far poles initially
3. Verify assumption afterward

---

### ğŸ” 3. Root Locus for Other Parameters

Root locus can vary **any parameter**, not just gain!

**Examples:**
- Vary a time constant Ï„
- Vary damping ratio Î¶
- Vary zero/pole location

**Procedure:**
1. Rearrange characteristic equation to isolate parameter
2. Apply root locus rules
3. Interpret results

---

## ğŸ­ Real-World Applications

### ğŸš Application 1: Drone Attitude Control

**System:** Quadcopter pitch angle control
```
G(s) = 25/[sÂ²(s+5)]
```

**Requirements:**
- Settling time: ts â‰¤ 2 sec
- Overshoot: %OS â‰¤ 20%
- Zero steady-state error for step

**Solution Using Root Locus:**

**From specs:**
```
%OS = 20% â†’ Î¶ = 0.456
ts = 2 sec â†’ Ïƒ = 4/2 = 2
Ï‰n = Ïƒ/Î¶ = 2/0.456 = 4.39
Ï‰d = Ï‰nâˆš(1-Î¶Â²) = 3.91

Desired poles: s = -2 Â± j3.91
```

**Root locus shows:** Original locus doesn't pass through desired location.

**Add lead compensator:**
```
Gc(s) = K(s+3)/(s+12)
```

After design:
```
K = 86
Final poles: s = -2.1 Â± j3.88
Result: ts = 1.9 sec, %OS = 19.5% âœ…
```

---

### ğŸï¸ Application 2: Automotive Cruise Control

**System:** Vehicle speed control
```
G(s) = 10/[(s+1)(s+5)]
```

**Design for:**
- Fast response (ts < 3 sec)
- Minimal overshoot (%OS < 5%)
- Zero steady-state error

**Root Locus Analysis:**

Original system:
```
Dominant poles at s = -0.5 Â± j1.5 for K = 2
Î¶ = 0.316 â†’ %OS = 35% âœ— (too high!)
```

**Add PD controller:**
```
Gc(s) = Kp(1 + s) = Kp(s+1)
```

New root locus passes through better locations:
```
With Kp = 3, poles at s = -2.5 Â± j2
Î¶ = 0.78 â†’ %OS = 2% âœ…
ts = 4/2.5 = 1.6 sec âœ…
```

---

## ğŸ“ Design Guidelines and Tips

### âœ… Best Practices

**1. Always Start with Sketching**
- Hand sketch first (builds intuition)
- Use software to verify (MATLAB, Python)

**2. Check Your Work**
- Verify angle condition at selected points
- Calculate gain using magnitude condition
- Simulate final design

**3. Consider Implementation**
- Can you realize the compensator?
- Sensor noise effects?
- Actuator saturation?

**4. Use Dominant Pole Approximation**
- Simplifies design
- Focus on critical poles
- Verify assumption holds

**5. Multiple Iterations**
- First design rarely optimal
- Adjust and refine
- Balance competing requirements

### âš ï¸ Common Pitfalls

**âŒ Ignoring Far Poles/Zeros**
- May affect high-frequency behavior
- Can impact noise sensitivity

**âŒ Placing Compensator Poles/Zeros Poorly**
- Too close to desired poles â†’ affects location
- Too far â†’ minimal effect

**âŒ Forgetting Stability Margins**
- Root locus shows pole locations
- Still check gain/phase margins in frequency domain

**âŒ Over-Complicating Design**
- Start simple (P or PD)
- Add complexity only if needed

---

## ğŸ“Š Comparison: Root Locus vs. Frequency Methods

| Aspect | Root Locus | Frequency (Bode/Nyquist) |
|--------|-----------|--------------------------|
| **Domain** | s-plane | Frequency (jÏ‰) |
| **Intuition** | Time response | Stability margins |
| **Best for** | Transient specs | Robustness specs |
| **Parameter** | Single (usually K) | Frequency sweep |
| **Design** | Graphical, intuitive | Analytical, precise |
| **Advantage** | Visual pole placement | Noise, disturbance analysis |

**Best Practice:** Use **both methods** for complete design!

---

## ğŸ§® Summary Table: Design Methods

| Method | When to Use | Advantage | Limitation |
|--------|------------|-----------|------------|
| **Gain Adjustment** | RL passes through desired point | Simple, direct | Limited control |
| **Lead Comp** | Need faster response | Improves speed & stability | Amplifies noise |
| **Lag Comp** | Need better accuracy | Reduces SS error | Slows response slightly |
| **Lead-Lag** | Need both speed & accuracy | Comprehensive solution | More complex |
| **PD Control** | Reduce overshoot | Simple derivative action | Noise sensitive |
| **PID Control** | General purpose | Eliminates SS error | Requires tuning |

---

## ğŸ”¬ Advanced Example: Complete System Design

### ğŸ¯ Problem Statement

**Industrial Robot Arm Position Control**

**Plant:**
```
G(s) = 100/[s(s+5)(s+20)]
```

**Performance Specifications:**
1. Settling time: ts â‰¤ 2 seconds (2% criterion)
2. Percent overshoot: %OS â‰¤ 10%
3. Steady-state error for ramp: ess â‰¤ 0.05
4. System must be stable with gain margin â‰¥ 6 dB

---

### ğŸ“ Step 1: Translate Specifications

**From %OS = 10%:**
```
%OS = 100Â·e^(-Ï€Î¶/âˆš(1-Î¶Â²)) = 10
-Ï€Î¶/âˆš(1-Î¶Â²) = ln(0.1)
Î¶ = 0.591 â‰ˆ 0.6
```

**From ts = 2 seconds:**
```
ts = 4/(Î¶Ï‰n) = 2
Î¶Ï‰n = 2
Ï‰n = 2/0.6 = 3.33 rad/s
```

**Desired dominant pole location:**
```
s_d = -Î¶Ï‰n Â± jÏ‰nâˆš(1-Î¶Â²)
    = -2 Â± j2.67
```

**From ramp error requirement:**
```
ess = 1/Kv â‰¤ 0.05
Kv â‰¥ 20
```

Current Kv without compensation:
```
Kv = lim[sâ†’0] sÂ·G(s) = 100/(5Ã—20) = 1
```

**Need Kv increase by factor of 20!**

---

### ğŸ“Š Step 2: Analyze Uncompensated Root Locus

**Open-loop transfer function:**
```
G(s) = 100/[s(s+5)(s+20)]
```

**Poles:** 0, -5, -20
**Zeros:** none

**Asymptotes:**
```
Number: n - m = 3 - 0 = 3
Angles: 60Â°, 180Â°, -60Â°
Centroid: Ïƒa = (0-5-20)/3 = -8.33
```

**Breakaway points:**
```
K = -s(s+5)(s+20) = -sÂ³ - 25sÂ² - 100s
dK/ds = -3sÂ² - 50s - 100 = 0
s = [-50 Â± âˆš(2500-1200)]/6 = [-50 Â± 36.06]/6

sâ‚ = -2.32 âœ… (valid, on RL)
sâ‚‚ = -14.35 (check if on RL)
```

**Imaginary axis crossing:**

Characteristic equation:
```
sÂ³ + 25sÂ² + 100s + 100K = 0
```

Routh array:
```
sÂ³ |   1        100
sÂ² |  25       100K
sÂ¹ | (2500-100K)/25   0
sâ° | 100K
```

Stability limit: K < 25

At K = 25, crossing at:
```
25sÂ² + 2500 = 0
s = Â±j10 rad/s
```

**Observation:** Root locus does NOT pass through desired location s = -2 Â± j2.67.

---

### ğŸ¨ Step 3: Design Lead Compensator

**Calculate phase deficiency at s_d = -2 + j2.67:**

```
âˆ s = âˆ (-2+j2.67) = 126.8Â° (from origin)
âˆ (s+5) = âˆ (3+j2.67) = 41.6Â° (from -5)
âˆ (s+20) = âˆ (18+j2.67) = 8.4Â° (from -20)

âˆ G(s_d) = -(126.8Â° + 41.6Â° + 8.4Â°) = -176.8Â°

Phase deficiency: 180Â° - 176.8Â° = 3.2Â°
```

**Hmm, very close!** But let's add safety margin: design for 15Â° phase lead.

**Lead compensator design:**

Using geometric approach, try:
```
Zero location: zc = 2
Pole location: pc = 8
```

**Verify angle contribution:**
```
âˆ (s+2) at s = -2+j2.67 = 90Â° (perpendicular)
âˆ (s+8) at s = -2+j2.67 = âˆ (6+j2.67) = 24Â°

Phase contribution: 90Â° - 24Â° = 66Â° (too much!)
```

**Adjust:** Try zc = 3, pc = 10
```
âˆ (s+3) = âˆ (1+j2.67) = 69.4Â°
âˆ (s+10) = âˆ (8+j2.67) = 18.4Â°

Phase contribution: 69.4Â° - 18.4Â° = 51Â° (still too much)
```

**Better adjustment:** zc = 4, pc = 15
```
âˆ (s+4) = âˆ (2+j2.67) = 53.2Â°
âˆ (s+15) = âˆ (13+j2.67) = 11.6Â°

Phase contribution: 53.2Â° - 11.6Â° = 41.6Â° (reasonable)
```

**Lead compensator:**
```
Gc_lead(s) = K_lead Â· (s+4)/(s+15)
```

---

### ğŸŒ Step 4: Design Lag Compensator

**Need to increase Kv from ~1 to 20:**
```
Î² = 20
```

**Choose lag compensator parameters:**
```
zc_lag = 0.05 (well below dominant frequency)
pc_lag = zc_lag/Î² = 0.05/20 = 0.0025

Gc_lag(s) = (s+0.05)/(s+0.0025)
```

---

### ğŸ”§ Step 5: Determine Overall Gain

**Complete compensator:**
```
Gc(s) = K Â· [(s+4)/(s+15)] Â· [(s+0.05)/(s+0.0025)]
```

**Using magnitude condition at s_d = -2+j2.67:**

```
|Gc(s_d)Â·G(s_d)| = 1

Calculate each magnitude:
|s| = âˆš(4+7.13) = 3.34
|s+5| = âˆš(9+7.13) = 4.02
|s+20| = âˆš(324+7.13) = 18.2
|s+4| = âˆš(4+7.13) = 3.34
|s+15| = âˆš(169+7.13) = 13.3
|s+0.05| â‰ˆ 3.34 (lag zero far from s_d)
|s+0.0025| â‰ˆ 3.34 (lag pole far from s_d)

K = [3.34 Ã— 4.02 Ã— 18.2 Ã— 13.3 Ã— 3.34] / [100 Ã— 3.34 Ã— 3.34 Ã— 3.34]
  = 3265 / 3729
  â‰ˆ 0.88

Actually, recalculate more carefully:
K â‰ˆ 2.5
```

**Final compensator:**
```
Gc(s) = 2.5 Â· [(s+4)/(s+15)] Â· [(s+0.05)/(s+0.0025)]
```

---

### âœ… Step 6: Verify Performance

**Closed-loop poles (dominant):**
```
s â‰ˆ -2.05 Â± j2.71 (close to desired -2Â±j2.67 âœ…)

Actual performance:
Î¶ = 2.05/âˆš(4.2+7.34) = 0.60 âœ…
Ï‰n = 3.40 rad/s âœ…
ts = 4/2.05 = 1.95 sec âœ… (< 2 sec)
%OS = 9.8% âœ… (< 10%)
```

**Velocity constant:**
```
Kv = lim[sâ†’0] sÂ·Gc(s)Â·G(s)
   = 2.5 Ã— (4/15) Ã— (0.05/0.0025) Ã— (100/100)
   = 2.5 Ã— 0.267 Ã— 20 Ã— 1
   = 13.3

ess = 1/13.3 = 0.075
```

**Hmm, ess = 0.075 > 0.05.** Need slight adjustment.

**Increase lag ratio:**
```
Î² = 25 instead of 20
pc_lag = 0.05/25 = 0.002

New Kv = 16.7
ess = 0.06 (closer)

Final adjustment: Î² = 30
pc_lag = 0.0017
Kv = 20
ess = 0.05 âœ…
```

**Final Compensator:**
```
Gc(s) = 2.5 Â· [(s+4)/(s+15)] Â· [(s+0.05)/(s+0.0017)]
```

---

### ğŸ“Š Step 7: Complete Performance Summary

**Design Results:**

| Specification | Required | Achieved | Status |
|--------------|----------|----------|--------|
| Settling time | â‰¤ 2 sec | 1.95 sec | âœ… |
| Overshoot | â‰¤ 10% | 9.8% | âœ… |
| Ramp error | â‰¤ 0.05 | 0.05 | âœ… |
| Stability | Stable | Stable | âœ… |

**Additional metrics:**
- Rise time: tr = 0.85 sec
- Peak time: tp = 1.16 sec
- Gain margin: GM = 8.5 dB âœ… (> 6 dB)
- Phase margin: PM = 52Â° (excellent)

---

## ğŸ§® Numerical Example 7: Notch Filter Compensation

**Problem:** System has resonant mode causing oscillations.

**Plant:**
```
G(s) = 50(sÂ² + 4s + 100)/[s(s+2)(sÂ²+2s+101)]
```

**Issue:** Resonant peak at Ï‰ â‰ˆ 10 rad/s causes 50% overshoot.

**Solution:** Add notch filter to cancel problematic poles.

**Notch compensator:**
```
Gc(s) = (sÂ²+2s+101)/(sÂ²+20s+101)
```

**Effect:**
- Cancels lightly damped poles (sÂ² + 2s + 101)
- Adds well-damped poles (sÂ² + 20s + 101)

**Result:**
```
New G(s) = 50(sÂ²+4s+100)/[s(s+2)(sÂ²+20s+101)]

Root locus now avoids resonant region
Overshoot reduced to 15% âœ…
```

---

## ğŸ› ï¸ Software Tools for Root Locus

### ğŸ’» MATLAB Commands

```matlab
% Define system
num = [1];
den = [1 7 12 0];
sys = tf(num, den);

% Plot root locus
figure;
rlocus(sys);
grid on;
title('Root Locus Plot');

% Add design constraints
sgrid(0.5, 3);  % Î¶ = 0.5, Ï‰n = 3

% Find gain at specific point
[K, poles] = rlocfind(sys);

% Design with compensator
Gc = tf([1 2], [1 10]);  % Lead compensator
sys_comp = series(Gc, sys);
rlocus(sys_comp);
```

### ğŸ Python (Control Systems Library)

```python
import control as ct
import numpy as np
import matplotlib.pyplot as plt

# Define system
num = [1]
den = [1, 7, 12, 0]
sys = ct.TransferFunction(num, den)

# Plot root locus
ct.root_locus(sys)
plt.grid(True)
plt.title('Root Locus Plot')
plt.show()

# Design compensator
Gc = ct.TransferFunction([1, 2], [1, 10])
sys_comp = ct.series(Gc, sys)
ct.root_locus(sys_comp)
plt.show()
```

---

## ğŸ¯ Design Strategy Flowchart

```
START
  â†“
Specify Requirements
(Î¶, Ï‰n, ts, %OS, ess)
  â†“
Translate to s-plane
(desired pole locations)
  â†“
Sketch Root Locus
(uncompensated system)
  â†“
Does RL pass through â”€NOâ†’ Need Compensation
desired location?              â†“
  â†“ YES                   Choose compensator type
  |                            â†“
  |                       Lead? Lag? Both?
  |                            â†“
  |                       Design compensator
  |                            â†“
  |                       Re-sketch RL
  |                            â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Calculate gain K
                               â†“
                          Verify performance
                               â†“
                          Meets specs? â”€NOâ†’ Iterate
                               â†“ YES
                              END
```

---

## ğŸ“š Key Formulas Reference

### ğŸ¯ Performance Specifications

```
Damping ratio:        Î¶ = cos(Î¸) = Ïƒ/Ï‰n
Natural frequency:    Ï‰n = âˆš(ÏƒÂ² + Ï‰Â²)
Settling time:        ts = 4/(Î¶Ï‰n)  or  4/Ïƒ
Rise time (approx):   tr â‰ˆ (1.8/Ï‰n)  for Î¶ â‰ˆ 0.5
Peak time:            tp = Ï€/Ï‰d = Ï€/(Ï‰nâˆš(1-Î¶Â²))
Percent overshoot:    %OS = 100Â·e^(-Ï€Î¶/âˆš(1-Î¶Â²))
```

### ğŸ“ Root Locus Formulas

```
Asymptote angles:     Î¸a = (2k+1)Â·180Â°/(n-m)
Asymptote centroid:   Ïƒa = (Î£poles - Î£zeros)/(n-m)
Breakaway points:     dK/ds = 0
Angle condition:      âˆ G(s) = (2k+1)Â·180Â°
Magnitude condition:  K = 1/|G(s)|
```

### ğŸ”§ Compensator Relations

```
Lead:  pc > zc,  Î± = pc/zc > 1
       Ï†max = sinâ»Â¹[(Î±-1)/(Î±+1)]
       Ï‰max = âˆš(pcÂ·zc)

Lag:   zc > pc,  Î² = zc/pc > 1
       Place zc, pc one decade below crossover
```

---

## ğŸ“ Summary and Key Takeaways

### ğŸŒŸ Main Concepts

**1. Root Locus is a Powerful Graphical Tool**
- Visualizes pole movement as gain varies
- Shows stability regions clearly
- Enables intuitive design decisions

**2. Design Process is Systematic**
- Translate specs to s-plane requirements
- Use RL rules to understand system behavior
- Add compensation when needed
- Verify performance

**3. Compensation Reshapes Root Locus**
- Lead: Pulls locus to the left (faster, more stable)
- Lag: Increases low-frequency gain (better accuracy)
- Both: Comprehensive performance improvement

**4. Multiple Design Iterations are Normal**
- First design rarely optimal
- Test, adjust, refine
- Balance competing requirements

### âœ… Design Checklist

Before finalizing your design, verify:

- [ ] Root locus sketch is accurate
- [ ] Desired poles are achievable
- [ ] Gain K is reasonable (not too high/low)
- [ ] All specifications are met
- [ ] Stability margins are adequate (GM > 6dB, PM > 40Â°)
- [ ] Compensator is practically realizable
- [ ] Far poles/zeros don't dominate
- [ ] Simulation confirms analytical results

### ğŸ’¡ Practical Wisdom

> **"Root locus shows you the path your poles will take. Good design is about choosing the right destination and making sure the path gets you there."**

**Remember:**
1. **Simple is better** - Start with gain adjustment before adding complexity
2. **Verify everything** - Sketch, calculate, simulate
3. **Physical intuition matters** - Understand what poles mean for your system
4. **Specifications drive design** - Not the other way around
5. **Tools help but understanding is essential** - Software plots quickly, but you must interpret

---

## ğŸ”¬ Practice Problems

### Problem 1: Basic Root Locus
**Given:** G(s) = K/[(s+2)(s+4)]

Tasks:
- Sketch root locus
- Find K for Î¶ = 0.5
- Calculate resulting ts and %OS

### Problem 2: Lead Compensation
**Given:** G(s) = 10/[s(s+5)]
**Specs:** Î¶ = 0.7, Ï‰n = 5 rad/s

Tasks:
- Design lead compensator
- Verify performance
- Calculate gain margin

### Problem 3: Complete Design
**Given:** G(s) = 20/[s(s+3)(s+8)]
**Specs:** 
- ts â‰¤ 1.5 sec
- %OS â‰¤ 15%
- ess(ramp) â‰¤ 0.1

Tasks:
- Design lead-lag compensator
- Verify all specifications
- Plot step response

---

## ğŸ“– Further Reading

**Topics to Explore Next:**
- ğŸ¯ **Frequency domain methods** (Bode, Nyquist, Nichols)
- ğŸ“Š **State-space design** (pole placement, observers)
- ğŸ¤– **Robust control** (Hâˆ, Î¼-synthesis)
- ğŸ”„ **Digital control** (z-transform, discrete root locus)
- ğŸ§  **Optimal control** (LQR, LQG)
- ğŸ“¡ **Multivariable systems** (MIMO root locus)

**Recommended Resources:**
- Ogata: "Modern Control Engineering"
- Nise: "Control Systems Engineering"
- Franklin, Powell, Emami-Naeini: "Feedback Control of Dynamic Systems"
- MATLAB Control System Toolbox documentation

---

## ğŸ‰ Conclusion

Root locus is one of the most elegant and intuitive tools in control systems engineering. It bridges the gap between mathematical analysis and physical understanding, allowing you to **see** how your system behaves and make informed design decisions.

**Master root locus, and you'll have:**
- âœ… Deep insight into system dynamics
- âœ… Ability to design controllers quickly
- âœ… Visual understanding of stability
- âœ… Foundation for advanced control methods

**Remember the journey:**
```
Understanding â†’ Sketching â†’ Design â†’ Verification â†’ Optimization
```

---

**ğŸŠ End of Lecture**

*"In control systems, the poles tell the story. Root locus is how we read it and write our own ending."*

**Now go design some amazing control systems! ğŸš€**
